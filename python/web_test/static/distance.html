<!DOCTYPE html>
<html>
<head>
    <title>ZigZag Control</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f5f5f5;
            margin: 0;
        }

        .container {
            display: grid;
            grid-template-columns: 25% 50% 25%;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }

        .status-container {
            grid-column: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1vw;
            padding-left: 1vw;
            padding-right: 1vw;
            font-size: 2.5vw;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            margin-bottom: 1vw;
        }

        .status-label {
            color: #7f8c8d;
            font-size: 2vw;
        }

        .status-value {
            color: #2c3e50;
        }

        .measurement-container {
            grid-column: 2;
            display: flex;
            align-items: baseline;
            justify-content: center;
        }

        .unit-container {
            grid-column: 3;
            display: flex;
            align-items: baseline;
            padding-left: 10vw;  /* Increased from 3vw to 5vw */
        }

        .position-value {
            font-size: 18vw;  /* Reduced from 20vw */
            font-weight: 300;
            color: #2c3e50;
            margin: 0;
            line-height: 1;
            text-align: right;
        }

        .position-unit {
            font-size: 6vw;
            color: #7f8c8d;
        }
    </style>
</head>
<body>f
    <div class="container">
        <div class="status-container">
            <div class="status-item">
                <span class="status-label">State:</span>
                <span class="status-value" id="status">UNKNOWN</span>
            </div>
            <div class="status-item">
                <span class="status-label">Max pos:</span>
                <span class="status-value" id="max-position">0 mm</span>
            </div>
            <div class="status-item">
                <span class="status-label">Offset:</span>
                <span class="status-value" id="offset-display">0 cm</span>
            </div>
        </div>
        <div class="measurement-container">
            <div class="position-value" id="position-value">0.000</div>
        </div>
        <div class="unit-container">
            <div class="position-unit">m</div>
        </div>
    </div>
    
    <script>
        const MAX_POSITION = 4205; 
        let positionOffset = parseInt(localStorage.getItem('positionOffset')) || 0;
        let isMetric = true;  // Default to metric, will be updated by server
        let currentPositionInMeters = 0;  // Track position in meters
        let isJogging = false;  // Add state tracker
        
        // Conversion functions
        const mToFt = m => m * 3.28084;
        const ftToM = ft => ft / 3.28084;

        // Function to format the current position based on unit
        function formatPosition(meters) {
            return isMetric ? 
                meters.toFixed(3) : 
                mToFt(meters).toFixed(2);  // Two decimals for imperial
        }

        // Function to update all display elements with current unit
        function updateDisplays() {
            const unit = isMetric ? 'm' : 'ft';
            document.querySelector('.position-unit').textContent = unit;
            positionValue.textContent = formatPosition(currentPositionInMeters);
            
            // Update max position (assuming it's also stored in meters)
            const maxMeters = parseFloat(maxPosition.textContent.split(':')[1]);
            maxPosition.textContent = `${formatPosition(maxMeters)} ${unit}`;
        }

        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectTimeout = 1000;
        let ws;

        function connect() {
            ws = new WebSocket(`ws://${window.location.host}/ws`);
            
            ws.onopen = function() {
                console.log('Connected');
                reconnectAttempts = 0;
                document.body.style.opacity = '1';
                // Modified polling to check jogging state
                setInterval(() => {
                    if (ws.readyState === WebSocket.OPEN && !isJogging) {
                        ws.send('?');
                    }
                }, 10000);
            };

            ws.onclose = function() {
                document.body.style.opacity = '0.5';
                if (reconnectAttempts < maxReconnectAttempts) {
                    setTimeout(function() {
                        reconnectAttempts++;
                        reconnectTimeout *= 2;  // Exponential backoff
                        connect();
                    }, reconnectTimeout);
                }
            };

            ws.onerror = function(err) {
                console.error('WebSocket error:', err);
            };

            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'position') {
                    currentPositionInMeters = (MAX_POSITION - data.value + positionOffset)/1000;
                    positionValue.textContent = formatPosition(currentPositionInMeters);
                } else if (data.type === 'unit') {
                    isMetric = data.isMetric;
                    updateDisplays();
                } else if (data.type === 'status') {
                    status.textContent = data.state.replace('MLOCKED', '').replace('|', '');
                    isJogging = data.state.includes('JOGGING');  // Track jogging state
                    isLocked = data.state.includes('MLOCKED');
                    const maxPositionMeters = (MAX_POSITION - data.max_position + positionOffset)/1000;
                    maxPosition.textContent = `${formatPosition(maxPositionMeters)} ${isMetric ? 'm' : 'ft'}`;
                } else if (data.type === 'offset') {
                    const previousOffset = positionOffset;
                    positionOffset = data.value;
                    offsetDisplay.textContent = `${(positionOffset/10).toFixed(1)} cm`;
                    // Update position using currentPositionInMeters
                    currentPositionInMeters = currentPositionInMeters - previousOffset/1000 + positionOffset/1000;
                    positionValue.textContent = formatPosition(currentPositionInMeters);
                }
            };
        }

        connect();  // Initial connection

        const positionValue = document.getElementById('position-value');
        const status = document.getElementById('status');
        const maxPosition = document.getElementById('max-position');
        const offsetDisplay = document.getElementById('offset-display');
        offsetDisplay.textContent = `${positionOffset} mm`;

        // Initialize displays with current unit
        updateDisplays();
    </script>
</body>
</html>